//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

const API_BASED_URL = 'https://365d-212-51-190-22.ngrok-free.app';

import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from 'axios';

import moment from 'moment';

export class ApiService {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null ? baseUrl : API_BASED_URL;

    const token = localStorage?.getItem('access_token') ?? '';

    if (token) {
      this.instance.defaults.headers.common['Authorization'] =
        'Bearer ' + token;
    } else {
      this.instance.defaults.headers.common['Authorization'] = '';
    }
  }

    /**
     * @return A list of all users
     */
    userAll( cancelToken?: CancelToken | undefined): Promise<UserGetDto[]> {
        let url_ = this.baseUrl + "/user/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserAll(_response);
        });
    }

<<<<<<< HEAD
    protected processUserAll(response: AxiosResponse): Promise<UserGetDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            if (Array.isArray(resultDatadefault)) {
                resultdefault = [] as any;
                for (let item of resultDatadefault)
                    resultdefault!.push(UserGetDto.fromJS(item));
            }
            else {
                resultdefault = <any>null;
            }
            return Promise.resolve<UserGetDto[]>(resultdefault);

        }
    }

    /**
     * @return The user with specified id
     */
    userById(id: number, cancelToken?: CancelToken | undefined): Promise<UserGetDto> {
        let url_ = this.baseUrl + "/user/byId/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserById(_response);
        });
    }

    protected processUserById(response: AxiosResponse): Promise<UserGetDto> {
=======
    /**
     * @return A list of all users
     */
    userAll( cancelToken?: CancelToken | undefined): Promise<UserGetDto[]> {
        let url_ = this.baseUrl + "/user/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserAll(_response);
        });
    }

    protected processUserAll(response: AxiosResponse): Promise<UserGetDto[]> {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
<<<<<<< HEAD
            resultdefault = UserGetDto.fromJS(resultDatadefault);
            return Promise.resolve<UserGetDto>(resultdefault);
=======
            if (Array.isArray(resultDatadefault)) {
                resultdefault = [] as any;
                for (let item of resultDatadefault)
                    resultdefault!.push(UserGetDto.fromJS(item));
            }
            else {
                resultdefault = <any>null;
            }
            return Promise.resolve<UserGetDto[]>(resultdefault);
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972

        }
    }

    /**
<<<<<<< HEAD
     * @return The user with specified email
     */
    userByEmail(body: StringEmailDto, cancelToken?: CancelToken | undefined): Promise<UserGetDto> {
        let url_ = this.baseUrl + "/user/byEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
=======
     * @return The user with specified id
     */
    userById(id: number, cancelToken?: CancelToken | undefined): Promise<UserGetDto> {
        let url_ = this.baseUrl + "/user/byId/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
<<<<<<< HEAD
            return this.processUserByEmail(_response);
        });
    }

    protected processUserByEmail(response: AxiosResponse): Promise<UserGetDto> {
=======
            return this.processUserById(_response);
        });
    }

    protected processUserById(response: AxiosResponse): Promise<UserGetDto> {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = UserGetDto.fromJS(resultDatadefault);
            return Promise.resolve<UserGetDto>(resultdefault);

        }
    }

    /**
<<<<<<< HEAD
     * @return The updated user
     */
    userUpdate(body: UserUpdateDto, cancelToken?: CancelToken | undefined): Promise<UserGetDto> {
        let url_ = this.baseUrl + "/user/update";
=======
     * @return The user with specified email
     */
    userByEmail(body: StringEmailDto, cancelToken?: CancelToken | undefined): Promise<UserGetDto> {
        let url_ = this.baseUrl + "/user/byEmail";
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
<<<<<<< HEAD
            method: "PUT",
=======
            method: "POST",
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
<<<<<<< HEAD
            return this.processUserUpdate(_response);
        });
    }

    protected processUserUpdate(response: AxiosResponse): Promise<UserGetDto> {
=======
            return this.processUserByEmail(_response);
        });
    }

    protected processUserByEmail(response: AxiosResponse): Promise<UserGetDto> {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = UserGetDto.fromJS(resultDatadefault);
            return Promise.resolve<UserGetDto>(resultdefault);

        }
    }

    /**
<<<<<<< HEAD
     * @param file (optional)
     * @return Upload avatar image for a user
     */
    userUploadAvatar(file: FileParameter | undefined, cancelToken?: CancelToken | undefined): Promise<UserGetDto> {
        let url_ = this.baseUrl + "/user/uploadAvatar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
=======
     * @return The updated user
     */
    userUpdate(body: UserUpdateDto, cancelToken?: CancelToken | undefined): Promise<UserGetDto> {
        let url_ = this.baseUrl + "/user/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
<<<<<<< HEAD
            return this.processUserUploadAvatar(_response);
        });
    }

    protected processUserUploadAvatar(response: AxiosResponse): Promise<UserGetDto> {
=======
            return this.processUserUpdate(_response);
        });
    }

    protected processUserUpdate(response: AxiosResponse): Promise<UserGetDto> {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = UserGetDto.fromJS(resultDatadefault);
            return Promise.resolve<UserGetDto>(resultdefault);

        }
    }

<<<<<<< HEAD
    authTest( cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/auth/test";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
=======
    /**
     * @param file (optional)
     * @return Upload avatar image for a user
     */
    userUploadAvatar(file: FileParameter | undefined, cancelToken?: CancelToken | undefined): Promise<UserGetDto> {
        let url_ = this.baseUrl + "/user/uploadAvatar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
<<<<<<< HEAD
            return this.processAuthTest(_response);
        });
    }

    protected processAuthTest(response: AxiosResponse): Promise<any> {
=======
            return this.processUserUploadAvatar(_response);
        });
    }

    protected processUserUploadAvatar(response: AxiosResponse): Promise<UserGetDto> {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
<<<<<<< HEAD
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    authSignUp(body: RegisterDto, cancelToken?: CancelToken | undefined): Promise<UserGetDto> {
        let url_ = this.baseUrl + "/auth/signUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
=======
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = UserGetDto.fromJS(resultDatadefault);
            return Promise.resolve<UserGetDto>(resultdefault);

        }
    }

    authTest( cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/auth/test";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
<<<<<<< HEAD
            return this.processAuthSignUp(_response);
        });
    }

    protected processAuthSignUp(response: AxiosResponse): Promise<UserGetDto> {
=======
            return this.processAuthTest(_response);
        });
    }

    protected processAuthTest(response: AxiosResponse): Promise<any> {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
<<<<<<< HEAD
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = UserGetDto.fromJS(resultData201);
            return Promise.resolve<UserGetDto>(result201);

=======
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
<<<<<<< HEAD
        return Promise.resolve<UserGetDto>(null as any);
    }

    authSignIn(body: LoginDto, cancelToken?: CancelToken | undefined): Promise<AccessTokenDto> {
        let url_ = this.baseUrl + "/auth/signIn";
=======
        return Promise.resolve<any>(null as any);
    }

    authSignUp(body: RegisterDto, cancelToken?: CancelToken | undefined): Promise<UserGetDto> {
        let url_ = this.baseUrl + "/auth/signUp";
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
<<<<<<< HEAD
            return this.processAuthSignIn(_response);
        });
    }

    protected processAuthSignIn(response: AxiosResponse): Promise<AccessTokenDto> {
=======
            return this.processAuthSignUp(_response);
        });
    }

    protected processAuthSignUp(response: AxiosResponse): Promise<UserGetDto> {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
<<<<<<< HEAD
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessTokenDto.fromJS(resultData200);
            return Promise.resolve<AccessTokenDto>(result200);
=======
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = UserGetDto.fromJS(resultData201);
            return Promise.resolve<UserGetDto>(result201);
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
<<<<<<< HEAD
        return Promise.resolve<AccessTokenDto>(null as any);
    }

    authForgotPwd(body: StringEmailDto, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/auth/forgotPwd";
=======
        return Promise.resolve<UserGetDto>(null as any);
    }

    authSignIn(body: LoginDto, cancelToken?: CancelToken | undefined): Promise<AccessTokenDto> {
        let url_ = this.baseUrl + "/auth/signIn";
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
<<<<<<< HEAD
=======
                "Accept": "application/json"
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
<<<<<<< HEAD
            return this.processAuthForgotPwd(_response);
        });
    }

    protected processAuthForgotPwd(response: AxiosResponse): Promise<void> {
=======
            return this.processAuthSignIn(_response);
        });
    }

    protected processAuthSignIn(response: AxiosResponse): Promise<AccessTokenDto> {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
<<<<<<< HEAD
            return Promise.resolve<void>(null as any);
=======
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessTokenDto.fromJS(resultData200);
            return Promise.resolve<AccessTokenDto>(result200);
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
<<<<<<< HEAD
        return Promise.resolve<void>(null as any);
    }

    authResetPwd(body: ResetPwdDto, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/auth/resetPwd";
=======
        return Promise.resolve<AccessTokenDto>(null as any);
    }

    authForgotPwd(body: StringEmailDto, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/auth/forgotPwd";
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
<<<<<<< HEAD
            return this.processAuthResetPwd(_response);
        });
    }

    protected processAuthResetPwd(response: AxiosResponse): Promise<void> {
=======
            return this.processAuthForgotPwd(_response);
        });
    }

    protected processAuthForgotPwd(response: AxiosResponse): Promise<void> {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

<<<<<<< HEAD
    /**
     * @return A list of festival
     */
    festivalGetMany(body: FestivalGetManyDto, cancelToken?: CancelToken | undefined): Promise<FestivalGetDto[]> {
        let url_ = this.baseUrl + "/festival/getMany";
=======
    authResetPwd(body: ResetPwdDto, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/auth/resetPwd";
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
<<<<<<< HEAD
                "Accept": "application/json"
=======
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
<<<<<<< HEAD
            return this.processFestivalGetMany(_response);
        });
    }

    protected processFestivalGetMany(response: AxiosResponse): Promise<FestivalGetDto[]> {
=======
            return this.processAuthResetPwd(_response);
        });
    }

    protected processAuthResetPwd(response: AxiosResponse): Promise<void> {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
<<<<<<< HEAD
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            if (Array.isArray(resultDatadefault)) {
                resultdefault = [] as any;
                for (let item of resultDatadefault)
                    resultdefault!.push(FestivalGetDto.fromJS(item));
            }
            else {
                resultdefault = <any>null;
            }
            return Promise.resolve<FestivalGetDto[]>(resultdefault);

        }
    }

    /**
     * @return The festival with specified id
     */
    festivalById(id: number, cancelToken?: CancelToken | undefined): Promise<FestivalGetDto> {
        let url_ = this.baseUrl + "/festival/byId/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
=======
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return A list of festival
     */
    festivalGetMany(body: FestivalGetManyDto, cancelToken?: CancelToken | undefined): Promise<FestivalGetDto[]> {
        let url_ = this.baseUrl + "/festival/getMany";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
<<<<<<< HEAD
            return this.processFestivalById(_response);
        });
    }

    protected processFestivalById(response: AxiosResponse): Promise<FestivalGetDto> {
=======
            return this.processFestivalGetMany(_response);
        });
    }

    protected processFestivalGetMany(response: AxiosResponse): Promise<FestivalGetDto[]> {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
<<<<<<< HEAD
            resultdefault = FestivalGetDto.fromJS(resultDatadefault);
            return Promise.resolve<FestivalGetDto>(resultdefault);
=======
            if (Array.isArray(resultDatadefault)) {
                resultdefault = [] as any;
                for (let item of resultDatadefault)
                    resultdefault!.push(FestivalGetDto.fromJS(item));
            }
            else {
                resultdefault = <any>null;
            }
            return Promise.resolve<FestivalGetDto[]>(resultdefault);
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972

        }
    }

    /**
     * @return The festival with specified name
     */
    festivalByName(body: FestivalNameDto, cancelToken?: CancelToken | undefined): Promise<FestivalGetDto> {
        let url_ = this.baseUrl + "/festival/byName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFestivalByName(_response);
        });
    }

    protected processFestivalByName(response: AxiosResponse): Promise<FestivalGetDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = FestivalGetDto.fromJS(resultDatadefault);
            return Promise.resolve<FestivalGetDto>(resultdefault);

        }
    }

    /**
     * @return The created festival
     */
    festivalCreatePost(body: FestivalCreateDto, cancelToken?: CancelToken | undefined): Promise<FestivalGetDto[]> {
        let url_ = this.baseUrl + "/festival/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
=======
     * @return The festival with specified id
     */
    festivalById(id: number, cancelToken?: CancelToken | undefined): Promise<FestivalGetDto> {
        let url_ = this.baseUrl + "/festival/byId/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
<<<<<<< HEAD
            return this.processFestivalCreatePost(_response);
        });
    }

    protected processFestivalCreatePost(response: AxiosResponse): Promise<FestivalGetDto[]> {
=======
            return this.processFestivalById(_response);
        });
    }

    protected processFestivalById(response: AxiosResponse): Promise<FestivalGetDto> {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
<<<<<<< HEAD
            if (Array.isArray(resultDatadefault)) {
                resultdefault = [] as any;
                for (let item of resultDatadefault)
                    resultdefault!.push(FestivalGetDto.fromJS(item));
            }
            else {
                resultdefault = <any>null;
            }
            return Promise.resolve<FestivalGetDto[]>(resultdefault);
=======
            resultdefault = FestivalGetDto.fromJS(resultDatadefault);
            return Promise.resolve<FestivalGetDto>(resultdefault);
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972

        }
    }

    /**
<<<<<<< HEAD
     * @return The created festival
     */
    festivalCreatePut(body: FestivalUpdateDto, cancelToken?: CancelToken | undefined): Promise<FestivalGetDto[]> {
        let url_ = this.baseUrl + "/festival/create";
=======
     * @return The festival with specified name
     */
    festivalByName(body: FestivalNameDto, cancelToken?: CancelToken | undefined): Promise<FestivalGetDto> {
        let url_ = this.baseUrl + "/festival/byName";
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
<<<<<<< HEAD
            method: "PUT",
=======
            method: "POST",
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
<<<<<<< HEAD
            return this.processFestivalCreatePut(_response);
        });
    }

    protected processFestivalCreatePut(response: AxiosResponse): Promise<FestivalGetDto[]> {
=======
            return this.processFestivalByName(_response);
        });
    }

    protected processFestivalByName(response: AxiosResponse): Promise<FestivalGetDto> {
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
<<<<<<< HEAD
            if (Array.isArray(resultDatadefault)) {
                resultdefault = [] as any;
                for (let item of resultDatadefault)
                    resultdefault!.push(FestivalGetDto.fromJS(item));
            }
            else {
                resultdefault = <any>null;
            }
            return Promise.resolve<FestivalGetDto[]>(resultdefault);

        }
    }
=======
            resultdefault = FestivalGetDto.fromJS(resultDatadefault);
            return Promise.resolve<FestivalGetDto>(resultdefault);

        }
    }

    /**
     * @return The created festival
     */
    festivalCreatePost(body: FestivalCreateDto, cancelToken?: CancelToken | undefined): Promise<FestivalGetDto[]> {
        let url_ = this.baseUrl + "/festival/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFestivalCreatePost(_response);
        });
    }

    protected processFestivalCreatePost(response: AxiosResponse): Promise<FestivalGetDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            if (Array.isArray(resultDatadefault)) {
                resultdefault = [] as any;
                for (let item of resultDatadefault)
                    resultdefault!.push(FestivalGetDto.fromJS(item));
            }
            else {
                resultdefault = <any>null;
            }
            return Promise.resolve<FestivalGetDto[]>(resultdefault);

        }
    }

    /**
     * @return The created festival
     */
    festivalCreatePut(body: FestivalUpdateDto, cancelToken?: CancelToken | undefined): Promise<FestivalGetDto[]> {
        let url_ = this.baseUrl + "/festival/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFestivalCreatePut(_response);
        });
    }

    protected processFestivalCreatePut(response: AxiosResponse): Promise<FestivalGetDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            if (Array.isArray(resultDatadefault)) {
                resultdefault = [] as any;
                for (let item of resultDatadefault)
                    resultdefault!.push(FestivalGetDto.fromJS(item));
            }
            else {
                resultdefault = <any>null;
            }
            return Promise.resolve<FestivalGetDto[]>(resultdefault);

        }
    }
>>>>>>> 23ef5e2820ce86c4c078a74a3e74aa85e736c972
}

export class UserGetDto implements IUserGetDto {
    id!: number;
    email!: string;
    firstname?: string | undefined;
    lastname?: string | undefined;
    avatarUrl?: string | undefined;

    [key: string]: any;

    constructor(data?: IUserGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.email = _data["email"];
            this.firstname = _data["firstname"];
            this.lastname = _data["lastname"];
            this.avatarUrl = _data["avatarUrl"];
        }
    }

    static fromJS(data: any): UserGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["email"] = this.email;
        data["firstname"] = this.firstname;
        data["lastname"] = this.lastname;
        data["avatarUrl"] = this.avatarUrl;
        return data;
    }
}

export interface IUserGetDto {
    id: number;
    email: string;
    firstname?: string | undefined;
    lastname?: string | undefined;
    avatarUrl?: string | undefined;

    [key: string]: any;
}

export class StringEmailDto implements IStringEmailDto {
    email!: string;

    [key: string]: any;

    constructor(data?: IStringEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): StringEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        return data;
    }
}

export interface IStringEmailDto {
    email: string;

    [key: string]: any;
}

export class UserUpdateDto implements IUserUpdateDto {
    id!: number;
    email!: string;
    firstname?: string;
    lastname?: string;

    [key: string]: any;

    constructor(data?: IUserUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.email = _data["email"];
            this.firstname = _data["firstname"];
            this.lastname = _data["lastname"];
        }
    }

    static fromJS(data: any): UserUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["email"] = this.email;
        data["firstname"] = this.firstname;
        data["lastname"] = this.lastname;
        return data;
    }
}

export interface IUserUpdateDto {
    id: number;
    email: string;
    firstname?: string;
    lastname?: string;

    [key: string]: any;
}

export class RegisterDto implements IRegisterDto {
    email!: string;
    password!: string;

    [key: string]: any;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterDto {
    email: string;
    password: string;

    [key: string]: any;
}

export class LoginDto implements ILoginDto {
    email!: string;
    password!: string;

    [key: string]: any;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginDto {
    email: string;
    password: string;

    [key: string]: any;
}

export class AccessTokenDto implements IAccessTokenDto {
    accessToken!: string;

    [key: string]: any;

    constructor(data?: IAccessTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accessToken = _data["accessToken"];
        }
    }

    static fromJS(data: any): AccessTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accessToken"] = this.accessToken;
        return data;
    }
}

export interface IAccessTokenDto {
    accessToken: string;

    [key: string]: any;
}

export class ResetPwdDto implements IResetPwdDto {
    password!: string;
    token!: string;

    [key: string]: any;

    constructor(data?: IResetPwdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.password = _data["password"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ResetPwdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPwdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["password"] = this.password;
        data["token"] = this.token;
        return data;
    }
}

export interface IResetPwdDto {
    password: string;
    token: string;

    [key: string]: any;
}

export class FestivalGetManyDto implements IFestivalGetManyDto {
    limit?: number;
    offset?: number;
    categoryId?: number;
    region?: string;

    [key: string]: any;

    constructor(data?: IFestivalGetManyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.categoryId = _data["categoryId"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): FestivalGetManyDto {
        data = typeof data === 'object' ? data : {};
        let result = new FestivalGetManyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["categoryId"] = this.categoryId;
        data["region"] = this.region;
        return data;
    }
}

export interface IFestivalGetManyDto {
    limit?: number;
    offset?: number;
    categoryId?: number;
    region?: string;

    [key: string]: any;
}

export class FestivalCategoryEntity implements IFestivalCategoryEntity {
    id!: number;
    label!: string;

    [key: string]: any;

    constructor(data?: IFestivalCategoryEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): FestivalCategoryEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FestivalCategoryEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["label"] = this.label;
        return data;
    }
}

export interface IFestivalCategoryEntity {
    id: number;
    label: string;

    [key: string]: any;
}

export class FestivalSubCategoryEntity implements IFestivalSubCategoryEntity {
    id!: number;
    label!: string;

    [key: string]: any;

    constructor(data?: IFestivalSubCategoryEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): FestivalSubCategoryEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FestivalSubCategoryEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["label"] = this.label;
        return data;
    }
}

export interface IFestivalSubCategoryEntity {
    id: number;
    label: string;

    [key: string]: any;
}

export class FestivalGetDto implements IFestivalGetDto {
    id!: number;
    category!: FestivalCategoryEntity | undefined;
    subCategory!: FestivalSubCategoryEntity[] | undefined;
    name!: string;
    region!: string;
    department!: string;
    zipcode!: string;
    address?: string | undefined;
    website?: string | undefined;
    email!: string;
    creationDate?: string | undefined;
    geoPosX!: number;
    geoPosY!: number;
    externalId?: string | undefined;
    dateStart!: moment.Moment;
    dateEnd!: moment.Moment;

    [key: string]: any;

    constructor(data?: IFestivalGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.category = _data["category"] ? FestivalCategoryEntity.fromJS(_data["category"]) : <any>undefined;
            if (Array.isArray(_data["subCategory"])) {
                this.subCategory = [] as any;
                for (let item of _data["subCategory"])
                    this.subCategory!.push(FestivalSubCategoryEntity.fromJS(item));
            }
            this.name = _data["name"];
            this.region = _data["region"];
            this.department = _data["department"];
            this.zipcode = _data["zipcode"];
            this.address = _data["address"];
            this.website = _data["website"];
            this.email = _data["email"];
            this.creationDate = _data["creationDate"];
            this.geoPosX = _data["geoPosX"];
            this.geoPosY = _data["geoPosY"];
            this.externalId = _data["externalId"];
            this.dateStart = _data["dateStart"] ? moment(_data["dateStart"].toString()) : <any>undefined;
            this.dateEnd = _data["dateEnd"] ? moment(_data["dateEnd"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FestivalGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new FestivalGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (Array.isArray(this.subCategory)) {
            data["subCategory"] = [];
            for (let item of this.subCategory)
                data["subCategory"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["region"] = this.region;
        data["department"] = this.department;
        data["zipcode"] = this.zipcode;
        data["address"] = this.address;
        data["website"] = this.website;
        data["email"] = this.email;
        data["creationDate"] = this.creationDate;
        data["geoPosX"] = this.geoPosX;
        data["geoPosY"] = this.geoPosY;
        data["externalId"] = this.externalId;
        data["dateStart"] = this.dateStart ? this.dateStart.toISOString() : <any>undefined;
        data["dateEnd"] = this.dateEnd ? this.dateEnd.toISOString() : <any>undefined;
        return data;
    }
}

export interface IFestivalGetDto {
    id: number;
    category: FestivalCategoryEntity | undefined;
    subCategory: FestivalSubCategoryEntity[] | undefined;
    name: string;
    region: string;
    department: string;
    zipcode: string;
    address?: string | undefined;
    website?: string | undefined;
    email: string;
    creationDate?: string | undefined;
    geoPosX: number;
    geoPosY: number;
    externalId?: string | undefined;
    dateStart: moment.Moment;
    dateEnd: moment.Moment;

    [key: string]: any;
<<<<<<< HEAD
=======
}

export class FestivalNameDto implements IFestivalNameDto {
    name!: string;

    [key: string]: any;

    constructor(data?: IFestivalNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FestivalNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new FestivalNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        return data;
    }
}

export interface IFestivalNameDto {
    name: string;

    [key: string]: any;
}

export class FestivalCreateDto implements IFestivalCreateDto {
    idCategory!: number;
    idSubCategory!: number[];
    name!: string;
    region!: string;
    department!: string;
    zipcode!: string;
    address!: string;
    website?: string | undefined;
    email!: string;
    creationDate?: string | undefined;
    geoPosX!: number;
    geoPosY!: number;
    dateStart!: string;
    dateEnd!: string;

    [key: string]: any;

    constructor(data?: IFestivalCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.idSubCategory = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.idCategory = _data["idCategory"];
            if (Array.isArray(_data["idSubCategory"])) {
                this.idSubCategory = [] as any;
                for (let item of _data["idSubCategory"])
                    this.idSubCategory!.push(item);
            }
            this.name = _data["name"];
            this.region = _data["region"];
            this.department = _data["department"];
            this.zipcode = _data["zipcode"];
            this.address = _data["address"];
            this.website = _data["website"];
            this.email = _data["email"];
            this.creationDate = _data["creationDate"];
            this.geoPosX = _data["geoPosX"];
            this.geoPosY = _data["geoPosY"];
            this.dateStart = _data["dateStart"];
            this.dateEnd = _data["dateEnd"];
        }
    }

    static fromJS(data: any): FestivalCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new FestivalCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["idCategory"] = this.idCategory;
        if (Array.isArray(this.idSubCategory)) {
            data["idSubCategory"] = [];
            for (let item of this.idSubCategory)
                data["idSubCategory"].push(item);
        }
        data["name"] = this.name;
        data["region"] = this.region;
        data["department"] = this.department;
        data["zipcode"] = this.zipcode;
        data["address"] = this.address;
        data["website"] = this.website;
        data["email"] = this.email;
        data["creationDate"] = this.creationDate;
        data["geoPosX"] = this.geoPosX;
        data["geoPosY"] = this.geoPosY;
        data["dateStart"] = this.dateStart;
        data["dateEnd"] = this.dateEnd;
        return data;
    }
}

export interface IFestivalCreateDto {
    idCategory: number;
    idSubCategory: number[];
    name: string;
    region: string;
    department: string;
    zipcode: string;
    address: string;
    website?: string | undefined;
    email: string;
    creationDate?: string | undefined;
    geoPosX: number;
    geoPosY: number;
    dateStart: string;
    dateEnd: string;

    [key: string]: any;
}

export class FestivalUpdateDto implements IFestivalUpdateDto {
    id!: number;
    idCategory!: number;
    idSubCategory!: number[];
    name!: string;
    region!: string;
    department!: string;
    zipcode!: string;
    address!: string;
    website?: string | undefined;
    email!: string;
    geoPosX!: number;
    geoPosY!: number;
    dateStart!: string;
    dateEnd!: string;

    [key: string]: any;

    constructor(data?: IFestivalUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.idSubCategory = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.idCategory = _data["idCategory"];
            if (Array.isArray(_data["idSubCategory"])) {
                this.idSubCategory = [] as any;
                for (let item of _data["idSubCategory"])
                    this.idSubCategory!.push(item);
            }
            this.name = _data["name"];
            this.region = _data["region"];
            this.department = _data["department"];
            this.zipcode = _data["zipcode"];
            this.address = _data["address"];
            this.website = _data["website"];
            this.email = _data["email"];
            this.geoPosX = _data["geoPosX"];
            this.geoPosY = _data["geoPosY"];
            this.dateStart = _data["dateStart"];
            this.dateEnd = _data["dateEnd"];
        }
    }

    static fromJS(data: any): FestivalUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new FestivalUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["idCategory"] = this.idCategory;
        if (Array.isArray(this.idSubCategory)) {
            data["idSubCategory"] = [];
            for (let item of this.idSubCategory)
                data["idSubCategory"].push(item);
        }
        data["name"] = this.name;
        data["region"] = this.region;
        data["department"] = this.department;
        data["zipcode"] = this.zipcode;
        data["address"] = this.address;
        data["website"] = this.website;
        data["email"] = this.email;
        data["geoPosX"] = this.geoPosX;
        data["geoPosY"] = this.geoPosY;
        data["dateStart"] = this.dateStart;
        data["dateEnd"] = this.dateEnd;
        return data;
    }
}

export interface IFestivalUpdateDto {
    id: number;
    idCategory: number;
    idSubCategory: number[];
    name: string;
    region: string;
    department: string;
    zipcode: string;
    address: string;
    website?: string | undefined;
    email: string;
    geoPosX: number;
    geoPosY: number;
    dateStart: string;
    dateEnd: string;

    [key: string]: any;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class GenerateApiServiceException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string | unknown,
    headers: { [key: string]: any },
    result: any,
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = typeof response == 'string' ? response : '';
    this.headers = headers;
    this.result = result;
  }

  protected isGenerateApiServiceException = true;

  static isGenerateApiServiceException(
    obj: any,
  ): obj is GenerateApiServiceException {
    return obj.isGenerateApiServiceException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string | unknown,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result;
  else
    throw new GenerateApiServiceException(
      message,
      status,
      response,
      headers,
      null,
    );
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true;
}
